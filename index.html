<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Timer">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Timer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #ffffff;
            height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .views-wrapper {
            width: 100%;
            height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            position: relative;
        }

        .views-container {
            display: flex;
            height: 100%;
            transition: transform 0.3s ease-out;
            width: 500%;
        }

        .view {
            width: 100vw;
            height: 100vh;
            min-height: 100dvh;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: env(safe-area-inset-top, 0);
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        .container {
            width: 100%;
            max-width: 500px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 40px;
        }

        .page-indicators {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 0) + 20px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .page-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: background 0.3s;
        }

        .page-indicator.active {
            background: rgba(255, 149, 0, 0.8);
        }

        .timer-display {
            position: relative;
            width: 280px;
            height: 280px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .circular-progress {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .progress-bg {
            fill: none;
            stroke: #3a3a3a;
            stroke-width: 8;
        }

        .progress-bar {
            fill: none;
            stroke: #ff9500;
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.3s linear;
        }

        .time-text {
            font-size: 56px;
            font-weight: 300;
            letter-spacing: -2px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .time-picker {
            display: flex;
            gap: 20px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .time-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .time-input label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .picker-container {
            width: 80px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .picker-container::before,
        .picker-container::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 40px;
            pointer-events: none;
            z-index: 1;
        }

        .picker-container::before {
            top: 0;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), transparent);
        }

        .picker-container::after {
            bottom: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.7), transparent);
        }

        .picker-scroll {
            height: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 40px 0;
        }

        .picker-scroll::-webkit-scrollbar {
            display: none;
        }

        .picker-item {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 24px;
            font-weight: 300;
            scroll-snap-align: center;
            transition: all 0.2s;
        }

        .picker-item.active {
            color: #ffffff;
            font-size: 28px;
        }

        .picker-highlight {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 40px;
            transform: translateY(-50%);
            border-top: 1px solid rgba(255, 149, 0, 0.3);
            border-bottom: 1px solid rgba(255, 149, 0, 0.3);
            pointer-events: none;
            z-index: 2;
        }

        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
        }

        .btn-start {
            background: #ff9500;
            color: #ffffff;
            width: 100px;
            height: 100px;
            font-size: 18px;
        }

        .btn-start:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .btn-pause {
            background: #ff9500;
            color: #ffffff;
            width: 100px;
            height: 100px;
            font-size: 18px;
        }

        .btn-pause:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .btn-reset {
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }

        .btn-reset:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .hidden {
            display: none !important;
        }

        .separator {
            font-size: 28px;
            color: rgba(255, 255, 255, 0.6);
        }

        .preset-selector {
            width: 100%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .preset-selector select {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            outline: none;
        }

        .preset-selector select option {
            background: #2d2d2d;
            color: #ffffff;
        }

        .overtime-indicator {
            color: #ff3b30;
            font-weight: 500;
        }

        .interval-controls {
            width: 100%;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .interval-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .interval-option:active {
            transform: scale(0.98);
        }

        .interval-option.selected {
            border-color: rgba(255, 149, 0, 0.8);
            background: rgba(255, 149, 0, 0.15);
        }

        .interval-option h3 {
            font-size: 18px;
            margin-bottom: 5px;
        }

        .interval-option p {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
        }

        .interval-status {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .view-title {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (max-width: 400px) {
            .timer-display {
                width: 240px;
                height: 240px;
            }

            .time-text {
                font-size: 48px;
            }

            .btn-start, .btn-pause {
                width: 80px;
                height: 80px;
            }

            .btn {
                width: 60px;
                height: 60px;
            }
        }

        /* Analog stopwatch styles */
        .analog-container {
            width: 320px;
            height: 320px;
            position: relative;
        }

        .analog-svg {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: pan-y; /* Allow vertical panning but not horizontal, enabling swipe navigation */
        }

        .dial-bg {
            fill: #000;
            stroke: #3a3a3a;
            stroke-width: 2;
        }

        .tick {
            stroke: rgba(255,255,255,0.55);
            stroke-width: 1;
        }

        .tick.major {
            stroke-width: 2.5;
        }

        .hand-second {
            stroke: #ff9500;
            stroke-width: 2.5;
            stroke-linecap: round;
            /* Ensure SVG transforms use the SVG viewBox as reference */
            transform-box: view-box;
            /* Center of main dial (viewBox is 0 0 200 200) */
            transform-origin: 50% 50%;
        }

        .hand-minute {
            stroke: #ff9500;
            stroke-width: 1.8;
            stroke-linecap: round;
            /* Ensure SVG transforms use the SVG viewBox as reference */
            transform-box: view-box;
            /* Rotate around subdial center at (100, 70) in SVG user units */
            transform-origin: 100px 70px;
        }

        .center-dot {
            fill: #ff9500;
        }

        .subdial {
            fill: none;
            stroke: rgba(255,255,255,0.25);
            stroke-width: 1.2;
        }

        .subdial-tick {
            stroke: rgba(255,255,255,0.55);
            stroke-width: 1;
        }

        .dial-number {
            fill: rgba(255,255,255,0.85);
            font-size: 12px;
            font-weight: 400;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .subdial-number {
            fill: rgba(255,255,255,0.8);
            font-size: 9px;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        /* Desktop top navigation */
        .top-nav {
            position: absolute;
            top: calc(env(safe-area-inset-top, 0) + 12px);
            left: 50%;
            transform: translateX(-50%);
            display: none; /* enabled on desktop via media query */
            gap: 8px;
            z-index: 15;
            background: rgba(0,0,0,0.35);
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(6px);
        }

        .top-nav button {
            background: transparent;
            color: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 9999px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
        }

        .top-nav button.active {
            background: rgba(255,149,0,0.25);
            border-color: rgba(255,149,0,0.7);
            color: #fff;
        }

        @media (hover: hover) and (pointer: fine) {
            .top-nav { display: flex; }
        }

        /* (Reverted) Interval view controls positioning: use default flow */

        /* ========== Angled (45° optimized) experimental pane styles ========== */
        .angled-pane {
            /* Clamp dial size so it never clips smaller viewports while still filling larger screens */
            --dial-size: clamp(220px, min(78vw, 60dvh), 340px);
            --tilt-angle: -42deg; /* Default tilt angle, adjustable via gesture or slider */
            --digit-font-size: 96px; /* Default font size, adjustable via pinch zoom */
        }
        .angled-pane .container {
            max-width: 620px;
            width: 100%;
            justify-content: center;
            gap: 40px;
            gap: clamp(28px, 8vh, 56px);
            padding: 40px 20px;
            padding: clamp(24px, 8dvh, 64px) clamp(16px, 6vw, 32px);
        }

        .angled-pane .timer-display {
            width: var(--dial-size);
            height: var(--dial-size);
            position: relative;
            z-index: 5;
            isolation: isolate;
            /* Keep the dial inside the viewport and compensate for the angled perspective */
            /* transform: translateY(2%) perspective(900px) rotateX(-25deg) scaleY(1.28); */
            /* transform: translateY(2%) perspective(900px) rotateX(-35deg) scaleY(1.28); */
            transform-origin: center;
        }

        /* Tilt the circular progress (SVG) by half the tilt angle */
        .angled-pane .circular-progress {
            /* Circle stays flat - only rotates to start at 12 o'clock, no 3D tilt */
            transform: rotate(-90deg);
            transform-origin: center;
            transition: transform 0.1s ease-out;
        }

        /* 3D transform test view styles (used by view1-3d) */
        .test-3d-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(120px, 1fr));
            gap: 18px;
            width: 100%;
            max-width: 720px;
            align-items: center;
        }

        .test-3d-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 8px;
        }

        .test-label {
            font-size: 13px;
            color: rgba(255,255,255,0.85);
            text-align: center;
        }

        .test-box {
            width: 120px;
            height: 84px;
            background: linear-gradient(180deg,#ff9500,#ff6a00);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #111;
            font-weight: 700;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
            transition: transform 300ms ease, box-shadow 300ms ease;
        }

        /* Parent perspective example - stronger tilt */
        .parent-perspective { perspective: 500px; }
        .parent-perspective .box-1 { transform: rotateX(-45deg); }

        /* Inline perspective() example - stronger tilt */
        .inline-perspective .box-2 { transform: perspective(500px) rotateX(-45deg); }

        /* translateZ requires perspective; increase translateZ and yaw */
        .translateZ { perspective: 500px; }
        .translateZ .box-3 { transform: translateZ(80px) rotateY(-22deg) rotateX(-12deg); }

        /* preserve-3d / backface-visibility test: a stronger flip */
        .preserve-3d .box-4 { width: 120px; height: 84px; position: relative; perspective: 600px; transform-style: preserve-3d; }
        .preserve-3d .box-4 .face { position: absolute; inset: 0; display:flex;align-items:center;justify-content:center;border-radius:10px;backface-visibility: hidden; }
        .preserve-3d .box-4 .face-front { background: linear-gradient(180deg,#34C759,#1FA84C); color: #021; }
        .preserve-3d .box-4 .face-back { background: linear-gradient(180deg,#5AC8FA,#2AA7E0); color: #012; transform: rotateY(180deg); }
        .preserve-3d .box-4:hover { transform: rotateY(220deg); }

        .angled-pane .circular-progress .progress-bg {
            stroke-width: 10;
            stroke: rgba(255,255,255,0.22);
        }

        .angled-pane .circular-progress .progress-bar {
            stroke-width: 12;
            filter: drop-shadow(0 2px 8px rgba(255,149,0,0.45));
        }

        .angled-pane .time-text {
            /* font-size: clamp(96px, 22vw, 180px); */
            font-size: var(--digit-font-size);
            font-weight: 700;
            font-family: 'SF Pro Rounded', 'Avenir Next Condensed', 'Helvetica Neue', -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: -1px;
            /* line-height: 0.88; */
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-stretch: semi-expanded;
            text-shadow:
                0 3px 0 rgba(0,0,0,0.4),
                0 8px 14px rgba(0,0,0,0.55);
            /* transform: translateY(-2%) rotateX(-16deg) scaleY(1.62); */
            /* transform:  translateY(45%) perspective(900px) rotateX(-22deg)  scaleY(2.12) scaleX(1.0); */
            transform:  translateY(45%) perspective(900px) rotateX(var(--tilt-angle))  scaleY(2.12) scaleX(1.0);
            /* transform:  translateY(45%) scaleY(2.12); */
            transform-origin: center bottom;
            transition: transform 0.1s ease-out, font-size 0.1s ease-out;
        }

        /* Dim styling for controls while running (still clickable) */
        .angled-pane .dimmed {
            opacity: 0.45;
            filter: blur(3px);
            transform: scale(1.015);
            will-change: filter, transform;
            transition: opacity 0.2s ease, filter 0.2s ease, transform 0.2s ease;
        }

        .angled-pane .preset-selector select {
            font-size: 20px;
        }

        .angled-pane .controls {
            position: relative;
            z-index: 3;
            gap: clamp(16px, 4vw, 28px);
        }

        .angled-pane .controls .btn {
            width: 72px;
            height: 72px;
            font-size: 16px;
            width: clamp(68px, 18vw, 80px);
            height: clamp(68px, 18vw, 80px);
            font-size: clamp(14px, 3.6vw, 17px);
        }

        .angled-pane .controls .btn-start,
        .angled-pane .controls .btn-pause {
            width: clamp(68px, 18vw, 80px);
            height: clamp(68px, 18vw, 80px);
            font-size: clamp(14px, 3.6vw, 17px);
        }

        .angled-pane .preset-selector {
            position: relative;
            z-index: 3;
        }

        .angled-pane .preset-selector select {
            font-size: clamp(16px, 4.5vw, 20px);
        }

        @media (max-width: 400px) {
            .angled-pane .timer-display {
                width: var(--dial-size);
                height: var(--dial-size);
            }
            .angled-pane .time-text {
                font-size: clamp(70px, 18vw, 120px);
            }
        }
        /* Docs viewer styles */
        .docs-tab {
            background: rgba(255,255,255,0.06);
            color: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.04);
            font-size: 14px;
        }

        .docs-tab.active {
            background: rgba(255,149,0,0.95);
            color: #111;
            border-color: rgba(255,149,0,0.95);
        }

        .docs-content h1, .docs-content h2, .docs-content h3 { color: #fff; }
        .docs-content p { color: rgba(255,255,255,0.9); line-height:1.5; }
        .docs-content code { background: rgba(0,0,0,0.4); padding:2px 6px; border-radius:4px; }
        .docs-content pre { background: rgba(0,0,0,0.45); padding:12px;border-radius:8px; overflow:auto; }
    </style>
</head>
<body>
    <div class="views-wrapper">
        <!-- Desktop navigation for view switching removed as requested -->
        <div class="views-container" id="viewsContainer">
            <!-- View 5: Predefined Timers (45° optimized) -->
            <div class="view angled-pane" id="view5">
                <div class="container">
                    <div class="timer-display">
                        <svg class="circular-progress" viewBox="0 0 280 280">
                            <circle class="progress-bg" cx="140" cy="140" r="130"></circle>
                            <!-- Non-uniformly spaced tick guides (compensated for perspective) -->
                            <g id="segmentedTicks5"></g>
                            <circle class="progress-bar" cx="140" cy="140" r="130" id="progressBar5"
                                    stroke-dasharray="817" 
                                    stroke-dashoffset="817"></circle>
                        </svg>
                        <div class="time-text" id="timeDisplay5">00:00</div>
                    </div>

                    <div class="preset-selector">
                        <select id="presetSelect5">
                            <option value="420">OPD - 7min</option>
                            <option value="210">OPD - 3min 30sec</option>
                            <option value="60">OPD - 1min</option>
                        </select>
                    </div>

                    <div class="controls">
                        <button class="btn btn-reset" id="resetBtn5" disabled>Reset</button>
                        <button class="btn btn-start" id="startBtn5">Start</button>
                        <button class="btn btn-pause hidden" id="pauseBtn5">Pause</button>
                    </div>
                </div>
            </div>

           
            <!-- View Docs: Markdown viewer -->
            <div class="view" id="viewDocs">
                <div class="container">
                    <div class="view-title">Docs</div>
                    <div id="docsTabs" style="width:100%;max-width:720px;">
                        <div id="docsTabList" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;"></div>
                        <div id="docsContent" style="background:rgba(0,0,0,0.35);padding:16px;border-radius:12px;max-height:60vh;overflow:auto;color:rgba(255,255,255,0.95);"></div>
                    </div>
                </div>
            </div>
          
        </div>

        <div class="page-indicators" id="pageIndicators">
        </div>
    </div>

    <script src="nosleep.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // Global state
        let noSleep = new NoSleep();
        let audioContext = null;
        const circumference = 817;
        let currentView = 0;

        // View-specific timers and state
        const viewState = {
            1: {
                timer: null,
                totalSeconds: 0,
                remainingSeconds: 0,
                selectedMinutes: 5,
                selectedSeconds: 0,
                endTimeMs: 0,
                remainingMs: 0,
                lastRemainingSec: null,
                wakeLock: null,
                lastBeepAt1Min: false
            },
            2: {
                timer: null,
                totalSeconds: 0,
                remainingSeconds: 0,
                presetSeconds: 420,
                isOvertime: false,
                overtimeSeconds: 0,
                endTimeMs: 0,
                remainingMs: 0,
                lastRemainingSec: null,
                overtimeStartMs: 0,
                overtimeFrozenSeconds: 0,
                overtimeElapsedMs: 0,
                wakeLock: null,
                lastBeepAt1Min: false
            },
            3: {
                timer: null,
                currentPhase: 'on', // 'countdown' | 'on' | 'off'
                remainingSeconds: 0,
                onDuration: 7,
                offDuration: 3,
                totalSeconds: 0,
                phaseEndTimeMs: 0,
                phaseRemainingMs: 0,
                lastRemainingSec: null,
                wakeLock: null,
                lastBeepAt1Min: false,
                countdownDuration: 5
            },
            4: {
                timer: null, // will hold RAF id when running
                startTime: 0,
                elapsedMs: 0,
                running: false,
                wakeLock: null
            },
            5: {
                timer: null,
                totalSeconds: 0,
                remainingSeconds: 0,
                presetSeconds: 420,
                isOvertime: false,
                overtimeSeconds: 0,
                endTimeMs: 0,
                remainingMs: 0,
                lastRemainingSec: null,
                overtimeStartMs: 0,
                overtimeFrozenSeconds: 0,
                overtimeElapsedMs: 0,
                wakeLock: null,
                lastBeepAt1Min: false
            }
        };

        // ==================== VIEW 5: PREDEFINED TIMER (ANGLED) ====================
        const view5 = {
            timeDisplay: document.getElementById('timeDisplay5'),
            presetSelect: document.getElementById('presetSelect5'),
            startBtn: document.getElementById('startBtn5'),
            pauseBtn: document.getElementById('pauseBtn5'),
            resetBtn: document.getElementById('resetBtn5'),
            linearFill: document.getElementById('linearFill5'),
            ticksGroup: document.getElementById('segmentedTicks5'),
            ticksBuilt: false,

            buildPerspectiveTicks() {
                if (this.ticksBuilt || !this.ticksGroup) return;
                const cx = 140, cy = 140, rOuter = 130, rInner = 122;
                const N = 60; // increments
                const k = 0.5; // more spacing near top
                const weights = Array.from({ length: N }, (_, i) => 1 + k * Math.cos((i / N) * 2 * Math.PI));
                const sumW = weights.reduce((a, b) => a + b, 0);
                let acc = 0;
                const angles = weights.map(w => { const t = (acc / sumW) * 2 * Math.PI; acc += w; return t; });
                for (let i = 0; i < N; i++) {
                    const a = angles[i];
                    const sin = Math.sin(a), cos = Math.cos(a);
                    const x1 = cx + rInner * sin;
                    const y1 = cy - rInner * cos;
                    const x2 = cx + rOuter * sin;
                    const y2 = cy - rOuter * cos;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1.toFixed(2));
                    line.setAttribute('y1', y1.toFixed(2));
                    line.setAttribute('x2', x2.toFixed(2));
                    line.setAttribute('y2', y2.toFixed(2));
                    line.setAttribute('stroke', 'rgba(255,255,255,0.22)');
                    line.setAttribute('stroke-width', '2');
                    this.ticksGroup.appendChild(line);
                }
                this.ticksBuilt = true;
            },

            updateDisplay() {
                let displayText;
                if (viewState[5].isOvertime) {
                    displayText = '+' + formatTime(viewState[5].overtimeSeconds);
                    this.timeDisplay.classList.add('overtime-indicator');
                } else {
                    displayText = formatTime(viewState[5].remainingSeconds);
                    this.timeDisplay.classList.remove('overtime-indicator');
                }
                this.timeDisplay.textContent = displayText;

                const progressEl = document.getElementById('progressBar5');
                if (!viewState[5].isOvertime) {
                    updateProgress('progressBar5', viewState[5].remainingSeconds, viewState[5].totalSeconds);

                    // Special coloring for OPD - 7min preset
                    if (viewState[5].totalSeconds === 420) {
                        const rem = Math.max(0, viewState[5].remainingSeconds);
                        const remainingMin = Math.ceil(rem / 60);
                        if (remainingMin >= 7 || remainingMin === 1) {
                            progressEl.style.stroke = '#ff9500';
                        } else if (remainingMin <= 6 && remainingMin >= 2) {
                            progressEl.style.stroke = '#34C759';
                        } else {
                            progressEl.style.stroke = '#ff9500';
                        }
                    } else {
                        progressEl.style.stroke = '#ff9500';
                    }
                    // Update linear progress (full countdown)
                    if (this.linearFill) {
                        if (viewState[5].totalSeconds > 0) {
                            const pct = 1 - (viewState[5].remainingSeconds / viewState[5].totalSeconds);
                            this.linearFill.style.width = `${Math.max(0, Math.min(1, pct)) * 100}%`;
                        } else {
                            this.linearFill.style.width = '0%';
                        }
                        this.linearFill.style.background = progressEl.style.stroke || '#ff9500';
                    }
                } else {
                    // In overtime, animate increasing indicator (count-up loop per 60s)
                    const elapsedMs = viewState[5].overtimeElapsedMs || (viewState[5].overtimeSeconds * 1000);
                    const cycleTotalSec = 60;
                    const withinSec = (elapsedMs % (cycleTotalSec * 1000)) / 1000;
                    updateProgress('progressBar5', withinSec, cycleTotalSec);
                    progressEl.style.stroke = '#ff3b30';
                    if (this.linearFill) {
                        this.linearFill.style.width = '100%';
                        this.linearFill.style.background = '#ff3b30';
                    }
                }
            },

            start() {
                if (viewState[5].remainingSeconds === 0 && !viewState[5].isOvertime) {
                    viewState[5].presetSeconds = parseInt(this.presetSelect.value);
                    viewState[5].totalSeconds = viewState[5].presetSeconds;
                    viewState[5].lastBeepAt1Min = false;
                }

                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Initialize end time or resume
                const now = performance.now();
                if (!viewState[5].isOvertime) {
                    if (viewState[5].remainingMs && viewState[5].remainingMs > 0) {
                        viewState[5].endTimeMs = now + viewState[5].remainingMs;
                    } else if (!viewState[5].endTimeMs) {
                        viewState[5].endTimeMs = now + viewState[5].totalSeconds * 1000;
                    }
                    viewState[5].lastRemainingSec = null;
                } else {
                    // resuming overtime
                    if (viewState[5].overtimeStartMs === 0) {
                        viewState[5].overtimeStartMs = now - viewState[5].overtimeFrozenSeconds * 1000;
                    }
                }

                noSleep.enable();
                requestWakeLock(5);
                
                this.startBtn.classList.add('hidden');
                this.pauseBtn.classList.remove('hidden');
                this.resetBtn.disabled = false;
                this.presetSelect.disabled = true;
                // Dim preset and controls while running (still clickable)
                this.presetSelect.classList.add('dimmed');
                this.pauseBtn.classList.add('dimmed');
                this.resetBtn.classList.add('dimmed');

                const loop = () => {
                    const now = performance.now();
                    if (!viewState[5].isOvertime) {
                        const remainingMs = Math.max(0, viewState[5].endTimeMs - now);
                        const remainingSec = Math.ceil(remainingMs / 1000);
                        viewState[5].remainingMs = remainingMs;
                        viewState[5].remainingSeconds = remainingSec;

                        if (viewState[5].lastRemainingSec !== remainingSec) {
                            if (shouldBeepAt1Min(viewState[5].totalSeconds, remainingSec, viewState[5].lastBeepAt1Min)) {
                                playBeep();
                                viewState[5].lastBeepAt1Min = true;
                            }
                            if (shouldBeepCountdown(viewState[5].totalSeconds, remainingSec)) {
                                playBeep();
                            }
                            viewState[5].lastRemainingSec = remainingSec;
                        }

                        if (remainingMs <= 0) {
                            playCompletionBeep();
                            viewState[5].isOvertime = true;
                            viewState[5].overtimeSeconds = 0;
                            viewState[5].overtimeFrozenSeconds = 0;
                            viewState[5].overtimeStartMs = performance.now();
                        }
                    } else {
                        // Overtime: count up precisely
                        const elapsed = now - viewState[5].overtimeStartMs;
                        viewState[5].overtimeElapsedMs = elapsed;
                        viewState[5].overtimeSeconds = Math.floor(elapsed / 1000);
                            // Update linear bar fill for full countdown
                            if (this.linearFill) {
                                if (viewState[5].totalSeconds > 0) {
                                    const pct = 1 - (viewState[5].remainingSeconds / viewState[5].totalSeconds);
                                    this.linearFill.style.width = `${Math.max(0, Math.min(1, pct)) * 100}%`;
                                    this.linearFill.style.background = progressEl.style.stroke || '#ff9500';
                                    this.linearFill.style.boxShadow = `0 2px 8px ${(progressEl.style.stroke || '#ff9500').replace(')', ',0.35)').replace('rgb', 'rgba')}`;
                                } else {
                                    this.linearFill.style.width = '0%';
                                    this.linearFill.style.background = '#ff9500';
                                }
                            }
                    }
                    this.updateDisplay();
                    viewState[5].timer = requestAnimationFrame(loop);
                };
                viewState[5].timer = requestAnimationFrame(loop);
            },
            pause() {
                cancelAnimationFrame(viewState[5].timer);
                viewState[5].timer = null;
                if (!viewState[5].isOvertime) {
                    viewState[5].remainingMs = Math.max(0, viewState[5].endTimeMs - performance.now());
                    viewState[5].remainingSeconds = Math.ceil(viewState[5].remainingMs / 1000);
                } else {
                    // Freeze overtime
                    viewState[5].overtimeFrozenSeconds = viewState[5].overtimeSeconds;
                    viewState[5].overtimeStartMs = 0;
                    viewState[5].overtimeElapsedMs = viewState[5].overtimeFrozenSeconds * 1000;
                }
                releaseWakeLock(5);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
                // Restore clarity on controls
                this.presetSelect.classList.remove('dimmed');
                this.pauseBtn.classList.remove('dimmed');
                this.resetBtn.classList.remove('dimmed');
            },

            stop() {
                cancelAnimationFrame(viewState[5].timer);
                viewState[5].timer = null;
                releaseWakeLock(5);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
                this.presetSelect.classList.remove('dimmed');
                this.pauseBtn.classList.remove('dimmed');
                this.resetBtn.classList.remove('dimmed');
            },

            reset() {
                this.stop();
                viewState[5].remainingSeconds = 0;
                viewState[5].totalSeconds = 0;
                viewState[5].isOvertime = false;
                viewState[5].overtimeSeconds = 0;
                viewState[5].endTimeMs = 0;
                viewState[5].remainingMs = 0;
                viewState[5].lastRemainingSec = null;
                viewState[5].overtimeStartMs = 0;
                viewState[5].overtimeFrozenSeconds = 0;
                viewState[5].overtimeElapsedMs = 0;
                viewState[5].lastBeepAt1Min = false;
                this.updateDisplay();
                this.resetBtn.disabled = true;
                this.presetSelect.disabled = false;
                // Restore default progress color
                const progressEl = document.getElementById('progressBar5');
                if (progressEl) progressEl.style.stroke = '#ff9500';
                this.presetSelect.classList.remove('dimmed');
                this.pauseBtn.classList.remove('dimmed');
                this.resetBtn.classList.remove('dimmed');
            }
        };

        // ==================== TILT ANGLE CONTROL FOR VIEW 5 ====================
        const tiltControl = {
            view5Element: null,
            currentAngle: -42, // default angle in degrees
            currentFontSize: 96, // default font size in pixels
            gestureStartY: 0,
            gestureStartAngle: 0,
            isGesturing: false,
            initialPinchDistance: 0,
            gestureStartFontSize: 0,

            init() {
                this.view5Element = document.getElementById('view5');
                
                // Load saved angle from localStorage
                const savedAngle = localStorage.getItem('tiltAngle5');
                if (savedAngle !== null) {
                    this.currentAngle = parseFloat(savedAngle);
                }
                
                // Load saved font size from localStorage
                const savedFontSize = localStorage.getItem('fontSize5');
                if (savedFontSize !== null) {
                    this.currentFontSize = parseFloat(savedFontSize);
                }
                
                this.applyAngle(this.currentAngle);
                this.applyFontSize(this.currentFontSize);

                // Load saved preset from localStorage
                const savedPreset = localStorage.getItem('preset5');
                if (savedPreset !== null) {
                    view5.presetSelect.value = savedPreset;
                    viewState[5].presetSeconds = parseInt(savedPreset);
                }

                // Save preset when changed
                view5.presetSelect.addEventListener('change', () => {
                    localStorage.setItem('preset5', view5.presetSelect.value);
                });

                // Two-finger gesture handlers (for both tilt and pinch)
                this.view5Element.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.view5Element.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.view5Element.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
            },

            handleTouchStart(e) {
                // Only handle gestures when timer is not running
                if (viewState[5].timer !== null) return;
                
                if (e.touches.length === 2) {
                    e.preventDefault();
                    
                    // Calculate initial distance between two fingers for pinch detection
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const dx = touch2.clientX - touch1.clientX;
                    const dy = touch2.clientY - touch1.clientY;
                    this.initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Store initial values for both gestures
                    const avgY = (touch1.clientY + touch2.clientY) / 2;
                    this.gestureStartY = avgY;
                    this.gestureStartAngle = this.currentAngle;
                    this.gestureStartFontSize = this.currentFontSize;
                    
                    this.isGesturing = true;
                }
            },

            handleTouchMove(e) {
                if (!this.isGesturing || e.touches.length !== 2) return;
                if (viewState[5].timer !== null) return;
                
                e.preventDefault();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate current distance for pinch detection
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const distanceChange = currentDistance - this.initialPinchDistance;
                
                // Calculate vertical movement for tilt detection
                const avgY = (touch1.clientY + touch2.clientY) / 2;
                const deltaYSigned = avgY - this.gestureStartY;
                
                // Apply BOTH gestures simultaneously if they have significant movement
                
                // Handle pinch zoom (if distance changed significantly)
                if (Math.abs(distanceChange) > 5) {
                    // Map distance change to font size change
                    // Every 50 pixels of pinch = 20px font size change
                    const fontSizeDelta = distanceChange / 2.5;
                    let newFontSize = this.gestureStartFontSize + fontSizeDelta;
                    
                    // Clamp font size between 60px and 160px
                    newFontSize = Math.max(60, Math.min(160, newFontSize));
                    
                    this.currentFontSize = newFontSize;
                    this.applyFontSize(newFontSize);
                }
                
                // Handle tilt gesture (if vertical movement is significant)
                if (Math.abs(deltaYSigned) > 5) {
                    // Map vertical movement to angle change (negative deltaY = more tilt)
                    // Sensitivity: 3 pixels = 1 degree
                    const angleDelta = -deltaYSigned / 3;
                    let newAngle = this.gestureStartAngle + angleDelta;
                    
                    // Clamp angle between -60 and -15 degrees
                    newAngle = Math.max(-60, Math.min(-15, newAngle));
                    
                    this.currentAngle = newAngle;
                    this.applyAngle(newAngle);
                }
            },

            handleTouchEnd(e) {
                if (this.isGesturing && e.touches.length < 2) {
                    this.isGesturing = false;
                    // Save both angle and font size since both can change in same gesture
                    this.saveAngle();
                    this.saveFontSize();
                }
            },

            applyAngle(angle) {
                this.view5Element.style.setProperty('--tilt-angle', `${angle}deg`);
            },
            
            applyFontSize(fontSize) {
                this.view5Element.style.setProperty('--digit-font-size', `${fontSize}px`);
            },

            saveAngle() {
                localStorage.setItem('tiltAngle5', this.currentAngle.toString());
            },
            
            saveFontSize() {
                localStorage.setItem('fontSize5', this.currentFontSize.toString());
            }
        };

        // Audio Context
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        function createBeep(frequency, duration) {
            const ctx = getAudioContext();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + duration);
        }

        function playBeep(duration = 0.1, frequency = 600) {
            createBeep(frequency, duration);
        }

        function playCompletionBeep() {
            createBeep(880, 1);
            if ('vibrate' in navigator) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
        }

        // Enhanced beep logic based on total time
        function shouldBeepAt1Min(totalSeconds, remainingSeconds, lastBeepAt1Min) {
            return totalSeconds >= 300 && remainingSeconds === 60 && !lastBeepAt1Min;
        }

        function shouldBeepCountdown(totalSeconds, remainingSeconds) {
            if (totalSeconds >= 60) {
                // For timers >= 1 min: beep at 5, 4, 3, 2, 1
                return remainingSeconds > 0 && remainingSeconds <= 5;
            } else {
                // For timers < 1 min: beep at 3, 2, 1
                return remainingSeconds > 0 && remainingSeconds <= 3;
            }
        }

        // Swipe handling
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        const viewsContainer = document.getElementById('viewsContainer');
        const pageIndicatorsContainer = document.getElementById('pageIndicators');
        let pageIndicators = [];

        function createPageIndicators() {
            const viewCount = document.querySelectorAll('#viewsContainer .view').length;
            pageIndicatorsContainer.innerHTML = '';
            pageIndicators = [];
            for (let i = 0; i < viewCount; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'page-indicator';
                if (i === currentView) indicator.classList.add('active');
                pageIndicatorsContainer.appendChild(indicator);
                pageIndicators.push(indicator);
            }
        }

        const maxViewIndex = () => document.querySelectorAll('#viewsContainer .view').length - 1;

        function updateView() {
            const offset = -currentView * 100;
            viewsContainer.style.transform = `translateX(${offset}vw)`;
            pageIndicators.forEach((indicator, index) => {
                indicator.classList.toggle('active', index === currentView);
            });
            // Desktop nav removed
        }

        viewsContainer.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        viewsContainer.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: true });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Only handle horizontal swipes
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                if (deltaX < 0 && currentView < maxViewIndex()) {
                    // Swipe left - next view
                    currentView++;
                    updateView();
                } else if (deltaX > 0 && currentView > 0) {
                    // Swipe right - previous view
                    currentView--;
                    updateView();
                }
            }
        }

        // Desktop nav click handlers
        // Desktop nav removed

        // Keyboard navigation (desktop): ArrowLeft/ArrowRight
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') {
                if (currentView < maxViewIndex()) { currentView++; updateView(); }
            } else if (e.key === 'ArrowLeft') {
                if (currentView > 0) { currentView--; updateView(); }
            }
        });

        // Wake Lock
        async function requestWakeLock(view) {
            if ('wakeLock' in navigator) {
                try {
                    viewState[view].wakeLock = await navigator.wakeLock.request('screen');
                    viewState[view].wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock released for view', view);
                    });
                } catch (err) {
                    console.log('Wake Lock error:', err);
                }
            }
        }

        async function releaseWakeLock(view) {
            if (viewState[view].wakeLock) {
                try {
                    await viewState[view].wakeLock.release();
                    viewState[view].wakeLock = null;
                } catch (err) {
                    console.error('Wake Lock release error:', err);
                }
            }
        }

        // Utility functions
        function formatTime(seconds, showSign = false) {
            const sign = showSign && seconds < 0 ? '-' : (showSign && seconds > 0 ? '+' : '');
            const absSeconds = Math.abs(seconds);
            const mins = Math.floor(absSeconds / 60);
            const secs = absSeconds % 60;
            return `${sign}${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateProgress(progressBarId, remaining, total) {
            const progressBar = document.getElementById(progressBarId);
            const progress = total > 0 ? remaining / total : 0;
            const offset = circumference * (1 - progress);
            progressBar.style.strokeDashoffset = offset;
        }

        // ==================== VIEW 1: CUSTOM TIMER ====================
        const view1 = {
            timeDisplay: document.getElementById('timeDisplay1'),
            minutesPicker: document.getElementById('minutesPicker1'),
            secondsPicker: document.getElementById('secondsPicker1'),
            startBtn: document.getElementById('startBtn1'),
            pauseBtn: document.getElementById('pauseBtn1'),
            resetBtn: document.getElementById('resetBtn1'),
            timePicker: document.getElementById('timePicker1'),

            initializePickers() {
                // Minutes picker (0-99)
                for (let i = 0; i <= 99; i++) {
                    const item = document.createElement('div');
                    item.className = 'picker-item';
                    item.textContent = String(i).padStart(2, '0');
                    item.dataset.value = i;
                    this.minutesPicker.appendChild(item);
                }

                // Seconds picker (0-59)
                for (let i = 0; i <= 59; i++) {
                    const item = document.createElement('div');
                    item.className = 'picker-item';
                    item.textContent = String(i).padStart(2, '0');
                    item.dataset.value = i;
                    this.secondsPicker.appendChild(item);
                }

                // Set initial scroll positions
                this.updatePickerScroll(this.minutesPicker, viewState[1].selectedMinutes);
                this.updatePickerScroll(this.secondsPicker, viewState[1].selectedSeconds);

                // Add scroll event listeners
                this.setupPickerScrollHandler(this.minutesPicker, (value) => { 
                    viewState[1].selectedMinutes = value; 
                });
                this.setupPickerScrollHandler(this.secondsPicker, (value) => { 
                    viewState[1].selectedSeconds = value; 
                });

                // Initial highlight
                this.updatePickerHighlight(this.minutesPicker);
                this.updatePickerHighlight(this.secondsPicker);
            },

            setupPickerScrollHandler(picker, valueSetter) {
                let scrollTimeout;
                picker.addEventListener('scroll', () => {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const value = this.getPickerValue(picker);
                        valueSetter(value);
                        this.updatePickerHighlight(picker);
                    }, 100);
                });
            },

            updatePickerScroll(picker, value) {
                const itemHeight = 40;
                picker.scrollTop = value * itemHeight;
            },

            getPickerValue(picker) {
                const itemHeight = 40;
                const scrollTop = picker.scrollTop;
                return Math.round(scrollTop / itemHeight);
            },

            updatePickerHighlight(picker) {
                const items = picker.querySelectorAll('.picker-item');
                const centerIndex = this.getPickerValue(picker);
                
                items.forEach((item, index) => {
                    if (index === centerIndex) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            },

            disablePickers() {
                this.minutesPicker.style.pointerEvents = 'none';
                this.secondsPicker.style.pointerEvents = 'none';
            },

            enablePickers() {
                this.minutesPicker.style.pointerEvents = 'auto';
                this.secondsPicker.style.pointerEvents = 'auto';
            },

            updateDisplay() {
                this.timeDisplay.textContent = formatTime(viewState[1].remainingSeconds);
                updateProgress('progressBar1', viewState[1].remainingSeconds, viewState[1].totalSeconds);
            },

            start() {
                // Compute total on first start
                if (viewState[1].totalSeconds === 0 || viewState[1].remainingSeconds === 0) {
                    viewState[1].totalSeconds = viewState[1].selectedMinutes * 60 + viewState[1].selectedSeconds;
                    if (viewState[1].totalSeconds <= 0) return;
                }

                // Enable audio context on user interaction
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Set end time (fresh or resume)
                const now = performance.now();
                if (viewState[1].remainingMs && viewState[1].remainingMs > 0) {
                    viewState[1].endTimeMs = now + viewState[1].remainingMs;
                } else if (!viewState[1].endTimeMs) {
                    viewState[1].endTimeMs = now + viewState[1].totalSeconds * 1000;
                }
                viewState[1].lastRemainingSec = null;
                viewState[1].lastBeepAt1Min = false;

                noSleep.enable();
                requestWakeLock(1);

                this.startBtn.classList.add('hidden');
                this.pauseBtn.classList.remove('hidden');
                this.resetBtn.disabled = false;
                this.timePicker.style.opacity = '0.5';
                this.disablePickers();

                const loop = () => {
                    const now = performance.now();
                    let remainingMs = Math.max(0, viewState[1].endTimeMs - now);
                    const remainingSec = Math.ceil(remainingMs / 1000);
                    viewState[1].remainingMs = remainingMs;
                    viewState[1].remainingSeconds = remainingSec;
                    this.updateDisplay();

                    // Beeps only when whole second changes
                    if (viewState[1].lastRemainingSec !== remainingSec) {
                        if (shouldBeepAt1Min(viewState[1].totalSeconds, remainingSec, viewState[1].lastBeepAt1Min)) {
                            playBeep();
                            viewState[1].lastBeepAt1Min = true;
                        }
                        if (shouldBeepCountdown(viewState[1].totalSeconds, remainingSec)) {
                            playBeep();
                        }
                        viewState[1].lastRemainingSec = remainingSec;
                    }

                    if (remainingMs <= 0) {
                        this.stop();
                        playCompletionBeep();
                        return;
                    }
                    viewState[1].timer = requestAnimationFrame(loop);
                };
                viewState[1].timer = requestAnimationFrame(loop);
            },

            pause() {
                cancelAnimationFrame(viewState[1].timer);
                viewState[1].timer = null;
                // Freeze remaining time
                viewState[1].remainingMs = Math.max(0, viewState[1].endTimeMs - performance.now());
                viewState[1].remainingSeconds = Math.ceil(viewState[1].remainingMs / 1000);
                this.updateDisplay();
                releaseWakeLock(1);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
            },

            stop() {
                cancelAnimationFrame(viewState[1].timer);
                viewState[1].timer = null;
                releaseWakeLock(1);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
            },

            reset() {
                this.stop();
                viewState[1].remainingSeconds = 0;
                viewState[1].totalSeconds = 0;
                viewState[1].lastBeepAt1Min = false;
                viewState[1].endTimeMs = 0;
                viewState[1].remainingMs = 0;
                viewState[1].lastRemainingSec = null;
                this.updateDisplay();
                this.resetBtn.disabled = true;
                this.timePicker.style.opacity = '1';
                this.enablePickers();
            }
        };

        // ==================== VIEW 2: PREDEFINED TIMER ====================
        const view2 = {
            timeDisplay: document.getElementById('timeDisplay2'),
            presetSelect: document.getElementById('presetSelect'),
            startBtn: document.getElementById('startBtn2'),
            pauseBtn: document.getElementById('pauseBtn2'),
            resetBtn: document.getElementById('resetBtn2'),

            updateDisplay() {
                let displayText;
                if (viewState[2].isOvertime) {
                    displayText = '+' + formatTime(viewState[2].overtimeSeconds);
                    this.timeDisplay.classList.add('overtime-indicator');
                } else {
                    displayText = formatTime(viewState[2].remainingSeconds);
                    this.timeDisplay.classList.remove('overtime-indicator');
                }
                this.timeDisplay.textContent = displayText;

                const progressEl = document.getElementById('progressBar2');
                if (!viewState[2].isOvertime) {
                    updateProgress('progressBar2', viewState[2].remainingSeconds, viewState[2].totalSeconds);

                    // Special coloring for OPD - 7min preset
                    if (viewState[2].totalSeconds === 420) {
                        const rem = Math.max(0, viewState[2].remainingSeconds);
                        const remainingMin = Math.ceil(rem / 60);
                        // First minute (7th minute): default orange
                        // Minutes 6..2: green
                        // Last minute (1): back to orange
                        if (remainingMin >= 7 || remainingMin === 1) {
                            progressEl.style.stroke = '#ff9500';
                        } else if (remainingMin <= 6 && remainingMin >= 2) {
                            progressEl.style.stroke = '#34C759';
                        } else {
                            // Fallback to default
                            progressEl.style.stroke = '#ff9500';
                        }
                    } else {
                        // Other presets use default color
                        progressEl.style.stroke = '#ff9500';
                    }
                } else {
                    // In overtime, animate increasing indicator (count-up loop per 60s)
                    const elapsedMs = viewState[2].overtimeElapsedMs || (viewState[2].overtimeSeconds * 1000);
                    const cycleTotalSec = 60;
                    const withinSec = (elapsedMs % (cycleTotalSec * 1000)) / 1000;
                    updateProgress('progressBar2', withinSec, cycleTotalSec);
                    // Turn circle red in overtime (match digital clock)
                    progressEl.style.stroke = '#ff3b30';
                }
            },

            start() {
                if (viewState[2].remainingSeconds === 0 && !viewState[2].isOvertime) {
                    viewState[2].presetSeconds = parseInt(this.presetSelect.value);
                    viewState[2].totalSeconds = viewState[2].presetSeconds;
                    viewState[2].lastBeepAt1Min = false;
                }

                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Initialize end time or resume
                const now = performance.now();
                if (!viewState[2].isOvertime) {
                    if (viewState[2].remainingMs && viewState[2].remainingMs > 0) {
                        viewState[2].endTimeMs = now + viewState[2].remainingMs;
                    } else if (!viewState[2].endTimeMs) {
                        viewState[2].endTimeMs = now + viewState[2].totalSeconds * 1000;
                    }
                    viewState[2].lastRemainingSec = null;
                } else {
                    // resuming overtime
                    if (viewState[2].overtimeStartMs === 0) {
                        viewState[2].overtimeStartMs = now - viewState[2].overtimeFrozenSeconds * 1000;
                    }
                }

                noSleep.enable();
                requestWakeLock(2);
                
                this.startBtn.classList.add('hidden');
                this.pauseBtn.classList.remove('hidden');
                this.resetBtn.disabled = false;
                this.presetSelect.disabled = true;

                const loop = () => {
                    const now = performance.now();
                    if (!viewState[2].isOvertime) {
                        const remainingMs = Math.max(0, viewState[2].endTimeMs - now);
                        const remainingSec = Math.ceil(remainingMs / 1000);
                        viewState[2].remainingMs = remainingMs;
                        viewState[2].remainingSeconds = remainingSec;

                        if (viewState[2].lastRemainingSec !== remainingSec) {
                            if (shouldBeepAt1Min(viewState[2].totalSeconds, remainingSec, viewState[2].lastBeepAt1Min)) {
                                playBeep();
                                viewState[2].lastBeepAt1Min = true;
                            }
                            if (shouldBeepCountdown(viewState[2].totalSeconds, remainingSec)) {
                                playBeep();
                            }
                            viewState[2].lastRemainingSec = remainingSec;
                        }

                        if (remainingMs <= 0) {
                            playCompletionBeep();
                            viewState[2].isOvertime = true;
                            viewState[2].overtimeSeconds = 0;
                            viewState[2].overtimeFrozenSeconds = 0;
                            viewState[2].overtimeStartMs = performance.now();
                        }
                    } else {
                        // Overtime: count up precisely
                        const elapsed = now - viewState[2].overtimeStartMs;
                        viewState[2].overtimeElapsedMs = elapsed;
                        viewState[2].overtimeSeconds = Math.floor(elapsed / 1000);
                    }
                    this.updateDisplay();
                    viewState[2].timer = requestAnimationFrame(loop);
                };
                viewState[2].timer = requestAnimationFrame(loop);
                       },

            pause() {
                cancelAnimationFrame(viewState[2].timer);
                viewState[2].timer = null;
                if (!viewState[2].isOvertime) {
                    viewState[2].remainingMs = Math.max(0, viewState[2].endTimeMs - performance.now());
                    viewState[2].remainingSeconds = Math.ceil(viewState[2].remainingMs / 1000);
                } else {
                    // Freeze overtime
                    viewState[2].overtimeFrozenSeconds = viewState[2].overtimeSeconds;
                    viewState[2].overtimeStartMs = 0;
                    viewState[2].overtimeElapsedMs = viewState[2].overtimeFrozenSeconds * 1000;
                }
                releaseWakeLock(2);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
            },

            stop() {
                cancelAnimationFrame(viewState[2].timer);
                viewState[2].timer = null;
                releaseWakeLock(2);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
            },

            reset() {
                this.stop();
                viewState[2].remainingSeconds = 0;
                viewState[2].totalSeconds = 0;
                viewState[2].isOvertime = false;
                viewState[2].overtimeSeconds = 0;
                viewState[2].endTimeMs = 0;
                viewState[2].remainingMs = 0;
                viewState[2].lastRemainingSec = null;
                viewState[2].overtimeStartMs = 0;
                viewState[2].overtimeFrozenSeconds = 0;
                viewState[2].overtimeElapsedMs = 0;
                viewState[2].lastBeepAt1Min = false;
                this.updateDisplay();
                this.resetBtn.disabled = true;
                this.presetSelect.disabled = false;
                // Restore default progress color
                const progressEl = document.getElementById('progressBar2');
                if (progressEl) progressEl.style.stroke = '#ff9500';
            }
        };

        // ==================== VIEW 3: INTERVAL TIMER ====================
        const view3 = {
            timeDisplay: document.getElementById('timeDisplay3'),
            startBtn: document.getElementById('startBtn3'),
            pauseBtn: document.getElementById('pauseBtn3'),
            resetBtn: document.getElementById('resetBtn3'),
            intervalStatus: document.getElementById('intervalStatus3'),
            intervalPicker: document.getElementById('intervalPicker3'),

            init() {
                // Build picker options
                const options = [
                    { label: '7 / 3 Intervals', on: 7, off: 3 },
                    { label: '30 / 10 Intervals', on: 30, off: 10 },
                    { label: '30s Continuous', on: 30, off: 0 },
                ];
                this.intervalOptionsData = options;

                options.forEach((opt, idx) => {
                    const item = document.createElement('div');
                    item.className = 'picker-item';
                    item.textContent = opt.label;
                    item.dataset.index = idx;
                    this.intervalPicker.appendChild(item);
                });

                // Default selection (index 0)
                this.updatePickerScroll(this.intervalPicker, 0);
                this.updatePickerHighlight(this.intervalPicker);
                viewState[3].onDuration = options[0].on;
                viewState[3].offDuration = options[0].off;

                // Scroll handler
                this.setupPickerScrollHandler(this.intervalPicker, (valueIndex) => {
                    const opt = this.intervalOptionsData[Math.max(0, Math.min(this.intervalOptionsData.length - 1, valueIndex))];
                    if (!viewState[3].timer) {
                        viewState[3].onDuration = opt.on;
                        viewState[3].offDuration = opt.off;
                    }
                });
            },

            // Picker helpers (mirrored from view1)
            updatePickerScroll(picker, value) {
                const itemHeight = 40;
                picker.scrollTop = value * itemHeight;
            },
            getPickerValue(picker) {
                const itemHeight = 40;
                const scrollTop = picker.scrollTop;
                return Math.round(scrollTop / itemHeight);
            },
            updatePickerHighlight(picker) {
                const items = picker.querySelectorAll('.picker-item');
                const centerIndex = this.getPickerValue(picker);
                items.forEach((item, index) => {
                    if (index === centerIndex) item.classList.add('active');
                    else item.classList.remove('active');
                });
            },
            setupPickerScrollHandler(picker, valueSetter) {
                let scrollTimeout;
                picker.addEventListener('scroll', () => {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const value = this.getPickerValue(picker);
                        valueSetter(value);
                        this.updatePickerHighlight(picker);
                    }, 100);
                });
            },

            updateDisplay() {
                this.timeDisplay.textContent = formatTime(viewState[3].remainingSeconds);
                
                // Update progress based on current phase
                if (viewState[3].currentPhase === 'countdown') {
                    updateProgress('progressBar3', viewState[3].remainingSeconds, viewState[3].countdownDuration);
                    this.intervalStatus.textContent = 'STARTING - ' + formatTime(viewState[3].remainingSeconds);
                    this.intervalStatus.style.background = 'rgba(255, 149, 0, 0.3)';
                } else if (viewState[3].currentPhase === 'on') {
                    updateProgress('progressBar3', viewState[3].remainingSeconds, viewState[3].onDuration);
                    this.intervalStatus.textContent = 'ON - ' + formatTime(viewState[3].remainingSeconds);
                    this.intervalStatus.style.background = 'rgba(255, 149, 0, 0.3)';
                } else {
                    updateProgress('progressBar3', viewState[3].remainingSeconds, viewState[3].offDuration);
                    this.intervalStatus.textContent = 'OFF - ' + formatTime(viewState[3].remainingSeconds);
                    this.intervalStatus.style.background = 'rgba(0, 0, 0, 0.3)';
                }
            },

            start() {
                if (viewState[3].timer === null) {
                    // Starting fresh or resume
                    if (!viewState[3].phaseEndTimeMs) {
                        // Always start with a 5s countdown with beeps
                        viewState[3].currentPhase = 'countdown';
                        viewState[3].totalSeconds = viewState[3].countdownDuration;
                        viewState[3].phaseEndTimeMs = performance.now() + viewState[3].countdownDuration * 1000;
                        viewState[3].lastRemainingSec = null;
                        viewState[3].lastBeepAt1Min = false;
                    } else if (viewState[3].phaseRemainingMs && viewState[3].phaseRemainingMs > 0) {
                        viewState[3].phaseEndTimeMs = performance.now() + viewState[3].phaseRemainingMs;
                    }
                }

                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                noSleep.enable();
                requestWakeLock(3);
                
                this.startBtn.classList.add('hidden');
                this.pauseBtn.classList.remove('hidden');
                this.resetBtn.disabled = false;

                const loop = () => {
                    const now = performance.now();
                    const remainingMs = Math.max(0, viewState[3].phaseEndTimeMs - now);
                    const remainingSec = Math.ceil(remainingMs / 1000);
                    viewState[3].phaseRemainingMs = remainingMs;
                    viewState[3].remainingSeconds = remainingSec;

                    if (viewState[3].lastRemainingSec !== remainingSec) {
                        if (viewState[3].currentPhase === 'countdown') {
                            // Beep every second during the 5s countdown
                            if (remainingSec > 0) playBeep();
                        } else {
                            if ( shouldBeepAt1Min(viewState[3].totalSeconds, remainingSec, viewState[3].lastBeepAt1Min)) {
                                playBeep();
                                viewState[3].lastBeepAt1Min = true;
                            }
                            if (shouldBeepCountdown(viewState[3].totalSeconds, remainingSec)) {
                                playBeep();
                            }
                        }
                        viewState[3].lastRemainingSec = remainingSec;
                    }

                    if (remainingMs <= 0) {
                        playCompletionBeep();
                        // Switch phase
                       
                        if (viewState[3].currentPhase === 'countdown') {
                            // Start the actual ON phase after countdown
                            viewState[3].currentPhase = 'on';
                            viewState[3].totalSeconds = viewState[3].onDuration;
                            viewState[3].phaseEndTimeMs = performance.now() + viewState[3].onDuration * 1000;
                        } else if (viewState[3].currentPhase === 'on') {
                            if (viewState[3].offDuration > 0) {
                                viewState[3].currentPhase = 'off';
                                viewState[3].totalSeconds = viewState[3].offDuration;
                                viewState[3].phaseEndTimeMs = performance.now() + viewState[3].offDuration * 1000;
                            } else {
                                // No off duration, restart on phase
                                viewState[3].totalSeconds = viewState[3].onDuration;
                                viewState[3].phaseEndTimeMs = performance.now() + viewState[3].onDuration * 1000;
                            }
                        } else {
                            viewState[3].currentPhase = 'on';
                            viewState[3].totalSeconds = viewState[3].onDuration;
                            viewState[3].phaseEndTimeMs = performance.now() + viewState[3].onDuration * 1000;
                        }
                        viewState[3].lastBeepAt1Min = false;
                    }

                    this.updateDisplay();
                    viewState[3].timer = requestAnimationFrame(loop);
                };
                viewState[3].timer = requestAnimationFrame(loop);
            },

            pause() {
                cancelAnimationFrame(viewState[3].timer);
                viewState[3].timer = null;
                viewState[3].phaseRemainingMs = Math.max(0, viewState[3].phaseEndTimeMs - performance.now());
                viewState[3].remainingSeconds = Math.ceil(viewState[3].phaseRemainingMs / 1000);
                this.updateDisplay();
                releaseWakeLock(3);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
            },

            stop() {
                cancelAnimationFrame(viewState[3].timer);
                viewState[3].timer = null;
                releaseWakeLock(3);
                noSleep.disable();
                
                this.startBtn.classList.remove('hidden');
                this.pauseBtn.classList.add('hidden');
            },

            reset() {
                this.stop();
                viewState[3].currentPhase = 'on';
                viewState[3].remainingSeconds = 0;
                viewState[3].totalSeconds = 0;
                viewState[3].phaseEndTimeMs = 0;
                viewState[3].phaseRemainingMs = 0;
                viewState[3].lastRemainingSec = null;
                viewState[3].lastBeepAt1Min = false;
                this.intervalStatus.textContent = 'Select an interval to start';
                this.intervalStatus.style.background = 'rgba(0, 0, 0, 0.3)';
                this.timeDisplay.textContent = '00:00';
                updateProgress('progressBar3', 0, 1);
                this.resetBtn.disabled = true;
            }
        };

        // ==================== VIEW 4: ANALOG STOPWATCH ====================
        const view4 = {
            timeDisplay: null,
            startBtn: null,
            pauseBtn: null,
            resetBtn: null,
            secondHand: null,
            minuteHand: null,
            ticksGroup: null,
            subticksGroup: null,
            numbersGroup: null,
            subnumbersGroup: null,

            init() {
                this.timeDisplay = document.getElementById('timeDisplay4');
                this.startBtn = document.getElementById('startBtn4');
                this.pauseBtn = document.getElementById('pauseBtn4');
                this.resetBtn = document.getElementById('resetBtn4');
                this.secondHand = document.getElementById('secondHand');
                this.minuteHand = document.getElementById('minuteHand');
                this.ticksGroup = document.getElementById('ticks');
                this.subticksGroup = document.getElementById('subticks');
                this.numbersGroup = document.getElementById('numbers');
                this.subnumbersGroup = document.getElementById('subnumbers');

                // Build main dial ticks (60)
                for (let i = 0; i < 60; i++) {
                    const angle = (i / 60) * 2 * Math.PI;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const rOuter = 94;
                    const rInner = i % 5 === 0 ? 88 : 90.5;
                    const x1 = 100 + rInner * sin;
                    const y1 = 100 - rInner * cos;
                    const x2 = 100 + rOuter * sin;
                    const y2 = 100 - rOuter * cos;
                    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
                    line.setAttribute('x1', x1.toFixed(2));
                    line.setAttribute('y1', y1.toFixed(2));
                    line.setAttribute('x2', x2.toFixed(2));
                    line.setAttribute('y2', y2.toFixed(2));
                    line.setAttribute('class', i % 5 === 0 ? 'tick major' : 'tick');
                    this.ticksGroup.appendChild(line);
                }

                // Add outer numbers at every 5 seconds
                for (let i = 5; i <= 60; i += 5) {
                    const angle = (i / 60) * 2 * Math.PI;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const rText = 78; // radius for text placement
                    const x = 100 + rText * Math.sin(angle);
                    const y = 100 - rText * Math.cos(angle);
                    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
                    text.setAttribute('x', x.toFixed(2));
                    text.setAttribute('y', y.toFixed(2));
                    text.setAttribute('class', 'dial-number');
                    text.textContent = i.toString();
                    this.numbersGroup.appendChild(text);
                }

                // Build subdial ticks (30 min)
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * 2 * Math.PI;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const rOuter = 24;
                    const rInner = i % 5 === 0 ? 19 : 21.5;
                    const cx = 100, cy = 70;
                    const x1 = cx + rInner * sin;
                    const y1 = cy - rInner * cos;
                    const x2 = cx + rOuter * sin;
                    const y2 = cy - rOuter * cos;
                    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
                    line.setAttribute('x1', x1.toFixed(2));
                    line.setAttribute('y1', y1.toFixed(2));
                    line.setAttribute('x2', x2.toFixed(2));
                    line.setAttribute('y2', y2.toFixed(2));
                    line.setAttribute('class', 'subdial-tick');
                    this.subticksGroup.appendChild(line);
                }

                // Add subdial numbers every 5 minutes (5..30)
                for (let i = 5; i <= 30; i += 5) {
                    const angle = (i / 30) * 2 * Math.PI;
                    const rText = 14; // text radius inside subdial
                    const cx = 100, cy = 70;
                    const x = cx + rText * Math.sin(angle);
                    const y = cy - rText * Math.cos(angle);
                    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
                    text.setAttribute('x', x.toFixed(2));
                    text.setAttribute('y', y.toFixed(2));
                    text.setAttribute('class', 'subdial-number');
                    text.textContent = i.toString();
                    this.subnumbersGroup.appendChild(text);
                }

                this.updateDisplay(0);
            },

            updateDisplay(ms) {
                const totalMs = Math.max(0, ms);
                const minutes = Math.floor(totalMs / 60000);
                const seconds = Math.floor((totalMs % 60000) / 1000);
                const centi = Math.floor((totalMs % 1000) / 10);
                this.timeDisplay.textContent = `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(centi).padStart(2,'0')}`;

                // Seconds hand: full rotation every 60s
                const secAngle = (totalMs % 60000) / 60000 * 360;
                this.secondHand.style.transform = `rotate(${secAngle}deg)`;

                // Minute subdial hand: full rotation every 30 minutes
                const minutesElapsed = totalMs / 60000; // float
                const subAngle = (minutesElapsed % 30) / 30 * 360;
                this.minuteHand.style.transform = `rotate(${subAngle}deg)`;
            },

            loop() {
                if (!viewState[4].running) return;
                const now = performance.now();
                const ms = viewState[4].elapsedMs + (now - viewState[4].startTime);
                this.updateDisplay(ms);
                viewState[4].timer = requestAnimationFrame(() => this.loop());
            },

            start() {
                if (!viewState[4].running) {
                    viewState[4].running = true;
                    viewState[4].startTime = performance.now();
                    noSleep.enable();
                    requestWakeLock(4);
                    this.startBtn.classList.add('hidden');
                    this.pauseBtn.classList.remove('hidden');
                    this.resetBtn.disabled = false;
                    viewState[4].timer = requestAnimationFrame(() => this.loop());
                }
            },

            pause() {
                if (viewState[4].running) {
                    cancelAnimationFrame(viewState[4].timer);
                    viewState[4].timer = null;
                    const now = performance.now();
                    viewState[4].elapsedMs += (now - viewState[4].startTime);
                    viewState[4].running = false;
                    releaseWakeLock(4);
                    noSleep.disable();
                    this.startBtn.classList.remove('hidden');
                    this.pauseBtn.classList.add('hidden');
                }
            },

            reset() {
                this.pause();
                viewState[4].elapsedMs = 0;
                this.updateDisplay(0);
                this.resetBtn.disabled = true;
            }
        };

        // ==================== INITIALIZATION ====================
        // Initialize views
        view1.initializePickers();
        view1.updateDisplay();
        view2.updateDisplay();
        view3.init();
        view4.init();
        view5.buildPerspectiveTicks();
        view5.updateDisplay();
        
        // Initialize tilt control for view 5
        tiltControl.init();

        // Event listeners for View 1
        view1.startBtn.addEventListener('click', () => view1.start());
        view1.pauseBtn.addEventListener('click', () => view1.pause());
        view1.resetBtn.addEventListener('click', () => view1.reset());

        // Event listeners for View 2
        view2.startBtn.addEventListener('click', () => view2.start());
        view2.pauseBtn.addEventListener('click', () => view2.pause());
        view2.resetBtn.addEventListener('click', () => view2.reset());
        // Ensure color resets appropriately when changing presets
        view2.presetSelect.addEventListener('change', () => {
            const progressEl = document.getElementById('progressBar2');
            if (progressEl) progressEl.style.stroke = '#ff9500';
            // Also update the display to reflect any potential time text reset
            view2.updateDisplay();
        });

        // Event listeners for View 3
        view3.startBtn.addEventListener('click', () => view3.start());
        view3.pauseBtn.addEventListener('click', () => view3.pause());
        view3.resetBtn.addEventListener('click', () => view3.reset());

        // Event listeners for View 4
        document.getElementById('startBtn4').addEventListener('click', () => view4.start());
        document.getElementById('pauseBtn4').addEventListener('click', () => view4.pause());
        document.getElementById('resetBtn4').addEventListener('click', () => view4.reset());

        // Event listeners for View 5
        document.getElementById('startBtn5').addEventListener('click', () => view5.start());
        document.getElementById('pauseBtn5').addEventListener('click', () => view5.pause());
        document.getElementById('resetBtn5').addEventListener('click', () => view5.reset());
        document.getElementById('presetSelect5').addEventListener('change', () => {
            const progressEl = document.getElementById('progressBar5');
            if (progressEl) progressEl.style.stroke = '#ff9500';
            view5.updateDisplay();
        });

        // Tap anywhere in View 5 (except controls/preset) to toggle start/pause
        const view5Root = document.getElementById('view5');
        view5Root.addEventListener('click', (e) => {
            const t = e.target;
            if (t.closest('.controls') || t.closest('.preset-selector')) return;
            if (viewState[5].timer) {
                view5.pause();
            } else {
                view5.start();
            }
        });

        // Handle page visibility changes to re-request wake lock if needed
        document.addEventListener('visibilitychange', async () => {
            for (let view = 1; view <= 5; view++) {
                if (viewState[view].timer && document.visibilityState === 'visible') {
                    await requestWakeLock(view);
                }
            }
        });

        // Resume audio context on user interaction (required by some browsers)
        function resumeAudioContext() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        
        document.addEventListener('touchstart', resumeAudioContext, { once: true });
        document.addEventListener('click', resumeAudioContext, { once: true });

        // ==================== DOCS VIEW LOADER ====================
        const docsData = {
            "Argumente-Gemini25pro.md": `Das ist die Kernkompetenz. Sie haben die "Überschriften" (die Argumente), jetzt brauchen Sie den "Artikel" dazu.

Hier ist eine systematische Checkliste. Gehen Sie diese Liste für **jedes einzelne Ihrer Argumente** durch. Nehmen wir an, Ihr Argument (Ihre "Überschrift") ist: *"Satire ist in despotischen Systemen die einzige Möglichkeit für Kritik."*

So verwandeln Sie das in einen 2-Minuten-Block:

---

### Checkliste: Vom Argument zum fertigen Rede-Baustein (ARE)

#### A - Argument (Die These)
Das ist Ihr initialer Gedanke.

* \`[ ]\` **1. Der Kernsatz (Ihr "A"):** Formulieren Sie Ihr Argument in *einem* klaren Satz.
    * *Beispiel:* "Mein Punkt ist: Humor (speziell Satire) muss alles dürfen, weil er in Diktaturen die einzige Waffe der Unterdrückten ist."

#### R - Reason (Die Begründung)
Hier beantworten Sie die "Warum"-Fragen, die Sie selbst gestellt haben.

* \`[ ]\` **2. "Warum ist das wahr?" (Die Logik):** Erklären Sie den Mechanismus. Tun Sie so, als würden Sie es einem 15-Jährigen erklären (die "Oma-Regel").
    * *Check-Frage:* Warum ist Humor eine *Waffe*?
    * *Antwort:* "In einem System, das jede direkte Kritik mit Gefängnis bestraft, kann man die Wahrheit nicht offen sagen. Der Humor ist eine Tarnkappe. Man kann den Diktator kritisieren, aber wenn man erwischt wird, sagt man: 'Es war doch nur ein Witz.' Er erlaubt es, das Unsagbare zu sagen."
* \`[ ]\` **3. "Warum ist das wichtig?" (Die Relevanz / "So what?"):** Was steht auf dem Spiel, wenn wir Ihrem Argument *nicht* zustimmen? Machen Sie es emotional und groß.
    * *Check-Frage:* Was passiert, wenn wir Satire dort verbieten?
    * *Antwort:* "Wenn wir Satire dort Grenzen setzen, nehmen wir den Menschen die *letzte* Form des Widerstands. Wir zementieren die Macht des Diktators. Es geht hier nicht nur um Lachen, es geht um intellektuelle Freiheit und politisches Überleben."

#### E - Example (Das Beispiel)
Hier machen Sie das Abstrakte greifbar. Das ist der schwierigste, aber wichtigste Teil, um Zeit zu füllen und zu überzeugen.

* \`[ ]\` **4. Wo sehe ich das? (Der Beleg):** Finden Sie *einen* konkreten Fall.

    **Systematische Suche nach Beispielen (wählen Sie EINES):**
    * **a) Im Alltag / Persönlich:** (Beim Thema Satire schwierig, aber bei "Mobbing" wäre es der *Schulhof*).
    * **b) In den Medien / Aktuell:** Gibt es einen aktuellen Fall? (z.B. ein Kabarettist, der in der Türkei/Russland verhaftet wurde? Die Böhmermann-Erdogan-Affäre als Beispiel für die *Grenzziehung*).
    * **c) In der Geschichte / Politik:** (Perfekt für dieses Argument).
        * *Beispiel:* "Denken Sie an die Flüsterwitze im Dritten Reich oder in der Sowjetunion. Das waren keine harmlosen Späße. Es war ein Akt des Trotzes. Es war die einzige Methode, die Absurdität des Regimes zu zeigen, ohne sofort exekutiert zu werden."
    * **d) Das Gedankenexperiment (Der Notnagel):** Wenn Ihnen nichts einfällt, nutzen Sie "Stellen Sie sich vor...".
        * *Beispiel:* "Stellen Sie sich vor, Sie leben in Nordkorea. Sie dürfen nichts Kritisches sagen. Aber Sie machen einen Witz über den Haarschnitt des Führers. In diesem Moment holen Sie sich ein kleines Stück Macht und Würde zurück."

#### Z - Zusammenfassung (Der Abschluss des Blocks)

* \`[ ]\` **5. Der Mini-Abschluss:** Fassen Sie A+R+E in einem Satz zusammen, der zum nächsten Argument überleitet.
    * *Beispiel:* "Wir sehen also: Humor als Waffe der Schwachen muss geschützt werden. Aber Humor ist nicht nur politisch wichtig, er ist auch..." *(...und hier kommt Ihr nächstes Argument an)*.

---

### Der Schlachtplan (Die "Runde Präsentation")

Eine 7-Minuten-Rede ist einfach:

1.  **Einleitung (ca. 1 Minute):**
    * [ ] Ein "Hook": Eine Frage, ein Zitat, eine provokante These.
    * [ ] Ihre Position klar benennen: "Ich bin FÜR/GEGEN..."
    * [ ] Vorschau (optional): "Ich werde das mit drei Punkten belegen: Erstens..., Zweitens..."
2.  **Hauptteil (ca. 5-6 Minuten):**
    * [ ] **ARE-Block 1** (ca. 2 Minuten)
    * [ ] **ARE-Block 2** (ca. 2 Minuten)
    * [ ] **ARE-Block 3** (oder Widerlegung eines erwarteten Gegenarguments) (ca. 2 Minuten)
3.  **Schluss (ca. 1 Minute):**
    * [ ] Die 3 "A"s (Ihre Hauptargumente) noch einmal zusammenfassen.
    * [ ] Zurück zum "Hook" der Einleitung kommen.
    * [ ] Ein starker Schlusssatz (Appell): "Deshalb..."

Ihr Problem ist nicht das Denken. Ihr Problem ist das "Übersetzen" Ihrer Gedanken in diese starre ARE-Struktur. Üben Sie diese Checkliste. Es ist ein Handwerk, keine Magie.

Wollen wir diese Checkliste einmal probehalber auf ein ganz anderes Thema anwenden, zum Beispiel "Sollten Hausaufgaben abgeschafft werden"?`,
            "OPD-Gemini25pro.md": `Das ist eine hervorragende Frage, denn die Rollen in einer Offenen Parlamentarischen Debatte (OPD) sind klar definiert. Die Struktur ist Ihr Rettungsanker, besonders wenn Sie mit der Nervosität oder dem "Füllen" der Zeit kämpfen.

Hier ist eine Checkliste für die drei Hauptredetypen. Das Ziel ist, Ihre (guten) Argumente in das "Korsett" der jeweiligen Rolle zu zwängen, damit sie ihre maximale Wirkung entfalten.

Die **ARE-Methode (Argument - Reason - Example)**, die wir besprochen haben, ist das *Werkzeug*, das Sie verwenden, um die Punkte [Argument 1] und [Argument 2] in diesen Checklisten auszufüllen.

---

### 🏛️ Checkliste 1: Die Regierungsrede (Eröffnend, PRO)

**Ihr Job:** Sie wollen eine Veränderung. Sie haben die **Beweislast**. Sie müssen der Jury beweisen, dass (A) der aktuelle Zustand (Status Quo) ein Problem hat und (B) Ihr Antrag (die Maßnahme) dieses Problem löst.

**Schlachtplan (ca. 7 Minuten):**

* [ ] **1. Einleitung (ca. 1 Min.)**
    * **Hook:** Beginnen Sie mit einer Geschichte, einer provokanten Frage oder einem überraschenden Fakt zum Thema. (z.B. "Stellen Sie sich vor...")
    * **Antrag vorstellen:** Nennen Sie den Antrag (das Thema) beim Namen.
    * **Positionierung:** "Als Regierung sagen wir heute klar: JA, wir müssen..."

* [ ] **2. Problembeschreibung (Status Quo) (ca. 1 Min.)**
    * **Was ist das Problem?** Warum debattieren wir das überhaupt? Was ist gerade schlecht? (z.B. "Aktuell ist es so, dass...")
    * **Warum ist das schlimm?** Für wen ist es schlimm? (Hier emotionalisieren).

* [ ] **3. Vorstellung der Maßnahme (Ihr "Modell") (ca. 0,5 Min.)**
    * **Was genau wollen Sie tun?** (z.B. "Wir fordern deshalb konkret: ...") *Seien Sie hier so präzise wie möglich.*

* [ ] **4. Argument 1 (Das stärkste Argument) (ca. 2 Min.)**
    * **A (Argument):** Die These. (z.B. "Unser wichtigster Punkt ist: Diese Maßnahme ist notwendig für Gerechtigkeit.")
    * **R (Reason):** Warum ist das wahr? (Die Logik...)
    * **E (Example):** Wo sehen wir das? (Statistik, Beispiel, Anekdote...)

* [ ] **5. Argument 2 (Das zweitstärkste Argument) (ca. 2 Min.)**
    * **A (Argument):** Die These. (z.B. "Zweitens ist diese Maßnahme auch wirtschaftlich sinnvoll.")
    * **R (Reason):** Warum?
    * **E (Example):** Beleg?

* [ ] **6. Schluss (ca. 0,5 Min.)**
    * **Zusammenfassung:** "Wir haben Ihnen gezeigt: Das Problem ist X, unsere Lösung ist Y, denn sie ist [Argument 1] und [Argument 2]."
    * **Appell:** "Stimmen Sie daher für diesen Antrag."

---

### 🛡️ Checkliste 2: Die Oppositionsrede (Eröffnend, CONTRA)

**Ihr Job:** Sie wollen die Veränderung (den Antrag) verhindern. Sie müssen die Beweislast der Regierung zerschlagen. Sie müssen **Zweifel säen**.

**Schlachtplan (ca. 7 Minuten):**

* [ ] **1. Einleitung (ca. 1 Min.)**
    * **Hook:** Beginnen Sie mit einem direkten Konter. "Die Regierung hat Ihnen gerade ein schönes Bild gemalt. Wir von der Opposition werden Ihnen zeigen, warum dieses Bild falsch ist."
    * **Positionierung:** "Wir sagen heute klar: NEIN, wir dürfen..."

* [ ] **2. Direkte Widerlegung (Clash) (ca. 2 Min.)**
    * **Regierungs-Problem angreifen:** "Die Regierung hat von einem Problem X gesprochen. Wir glauben: Dieses Problem existiert nicht / ist nicht so schlimm / wird falsch dargestellt, *weil*..."
    * **Regierungs-Argument 1 angreifen:** Nehmen Sie das stärkste Argument der Regierung und zerlegen Sie es. (z.B. "Ihr Beispiel war unpassend, *weil*..." oder "Ihre Logik (Reason) ist fehlerhaft, *denn*...")

* [ ] **3. Eigenes Argument 1 (Das stärkste Contra-Argument) (ca. 2 Min.)**
    * **A (Argument):** Die These. (z.B. "Unser wichtigster Punkt ist: Die Maßnahme der Regierung ist nicht nur unnötig, sie ist *schädlich*.")
    * **R (Reason):** Warum ist sie schädlich? (z.B. "Weil sie massive, unbeabsichtigte Nebenwirkungen hat...")
    * **E (Example):** Wo ist das schon mal schiefgegangen?

* [ ] **4. Eigenes Argument 2 (Das zweitstärkste Contra-Argument) (ca. 1,5 Min.)**
    * **A (Argument):** Die These. (z.B. "Zweitens ist der Plan der Regierung unbezahlbar/ungerecht/unpraktikabel.")
    * **R (Reason):** ...
    * **E (Example):** ...

* [ ] **5. Schluss (ca. 0,5 Min.)**
    * **Zusammenfassung:** "Wir haben die Argumente der Regierung widerlegt UND gezeigt, dass ihr Plan [Argument 1] und [Argument 2] ist."
    * **Appell:** "Lehnen Sie diesen gefährlichen Antrag ab."

---

### 🕊️ Checkliste 3: Die Freie Rede (Neutral / Vertiefend)

**Ihr Job:** Das ist die anspruchsvollste, aber auch freieste Rolle. Sie sind nicht an ein Team gebunden. Ihr Job ist es, die Debatte auf ein **neues Level** zu heben. Sie müssen das "Meta-Spiel" spielen.

**Schlachtplan (ca. 7 Minuten):**

* [ ] **1. Einleitung & Positionierung (ca. 1 Min.)**
    * **Hook:** "Wir haben jetzt eine Rede von der Regierung und eine von der Opposition gehört."
    * **Positionierung:** *Hier entscheiden Sie sich:*
        * *(A) Pro-Lager:* "Die Opposition hat die Kernpunkte der Regierung nicht verstanden. Ich werde der Regierung beipflichten, aber aus einem *anderen* Grund..."
        * *(B) Contra-Lager:* "Die Regierung hat ein wichtiges Problem genannt, aber ihre Lösung ist grundfalsch. Ich unterstütze die Opposition mit einem neuen Argument..."
        * *(C) Völlig neuer Blick:* "Beide Seiten haben das *eigentliche* Problem dieser Debatte übersehen. Es geht nämlich in Wahrheit um..."

* [ ] **2. Debatten-Analyse (Was wurde übersehen?) (ca. 2 Min.)**
    * **Regierungskritik:** "Die Regierung hat zwar Punkt X richtig gesehen, aber sie hat völlig vergessen, dass..."
    * **Oppositionskritik:** "Die Opposition hat zwar richtig auf die Kosten (Punkt Y) hingewiesen, aber sie ignoriert den moralischen Aspekt von..."
    * *(Hier glänzen Sie, indem Sie die "offensichtlichen" Dinge benennen, die die anderen im Eifer des Gefechts vergessen haben).*

* [ ] **3. Das "vergessene" Argument (Ihr Hauptargument) (ca. 3 Min.)**
    * **Das ist Ihr ARE-Block.** Nehmen Sie das Argument, das Ihrer Meinung nach das wichtigste der *ganzen Debatte* ist und das noch niemand genannt hat.
    * **A (Argument):** "Worüber wir wirklich reden müssen, ist..."
    * **R (Reason):** "Warum ist das der entscheidende Punkt? Weil..."
    * **E (Example):** "Das sehen wir ganz klar am Beispiel..."

* [ ] **4. Abwägung & Schluss (ca. 1 Min.)**
    * **Warum ist Ihr Punkt wichtiger?** "Wenn wir meinen Punkt [Argument] berücksichtigen, sehen wir, dass die Argumente der Regierung [schwächer/stärker] werden, *weil*..."
    * **Appell (Ihr Urteil):** "Deshalb, nach Abwägung aller Punkte – und insbesondere meines Punktes – müssen wir diesen Antrag [annehmen/ablehnen]."

---

Möchten Sie, dass wir eine dieser Checklisten nehmen und sie mit einem neuen Thema probeweise "befüllen"?`,
            "training.md": `## Debattieren

### Regierung 1
- **Antrag**
- **Struktur**
- **Status quo beschreiben** (wichtig)

### Opposition 1
- da kann man sagen "ja status quo darstellung der reg valide nicht valide"

### Regierung 2
- **Ergänzung** Schlussfolgernd auf der ersten rede auf nicht r1 widersprechen
- **Interagieren (mit opp1)**

### R3
- **abwägen**


## Restliches Scoring
### 30 Pkt Zwischenfragen
- Challengen die annahme im regelfall
- **Was ist der vergleich, wenn die massnahme nicht eingeführt wird** (das ist eine gute Variante, den finger in die wunde zu legen
- Framing ist wichtig

### 30 Pkt Zwischenreden (Antwort auf freie Rede)
- Wichtig, gut um Punkte zu machen
- **Werbend, um die person auf deine seite zu ziehen** "Wir können deine sorgen verstehen, abef wir glauben, wir können deine probleme besser lösen"
- Geheimtipp: ein geiles sprachbild, ueber das der vorredner gesprochen hat. Aufnehmen und umdrehen. Klammer in

### 15 Pkt Reinrufe
- es werden alle Zwischenrufe gewertet. Bei zwei guten und zwei pöbelnden wird gemittelt

## Scoring 

### Auftreten und Sprachkraft
- Stand
	- Stabil hingehen
	- (hochhuepfen und landen. Man landet stabil)
- Mimik
- Gestik
- Augenkontakt
	- Auf JurorInnen schauen. Jury muss man ueberzeugen. Das andere Team kann man per Definition nicht überzeugen. Und freie RednerInnen anschauen!

#### Sprachkraft
- Tonalität
- Bilder
- Grammatik
- Aussprache
- Ausreden und klarheit
- Tempo
- Einstieg
	- Gang zum pult sollte selbstbewusst und positiv sein
	- kurz am besten keine Geschichte
	- Aufmerksamkeit erregen und kurz sein
	- Maxi sagte keine geschichte sondern bock machen, dass die leute zuhoeren
 
Vor der rede
Zungenbrecher Blaukraut bleibt Blaukraut`
        };

        async function loadDocsIndex() {
            // Return hardcoded index
            return [
                { "file": "Argumente-Gemini25pro.md", "title": "Argumente Gemini 25 Pro" },
                { "file": "OPD-Gemini25pro.md", "title": "OPD Gemini 25 Pro" },
                { "file": "training.md", "title": "Training" }
            ];
        }

        // Hardcoded docs loading
        const docsTabList = document.getElementById('docsTabList');
        const docsContent = document.getElementById('docsContent');
        if (!docsTabList || !docsContent) return;

        const index = await loadDocsIndex();
        if (!index || !index.length) {
            docsContent.innerHTML = '<p>No docs found.</p>';
            return;
        }

        let activeBtn = null;

        async function openDoc(entry, btn) {
            if (activeBtn) activeBtn.classList.remove('active');
            btn.classList.add('active'); activeBtn = btn;
            docsContent.innerHTML = '<p>Loading...</p>';
            try {
                const md = docsData[entry.file];
                if (!md) throw new Error('Doc not found');
                docsContent.innerHTML = renderMarkdown(md);
            } catch (err) {
                docsContent.innerHTML = `
                    <p>Fehler beim Laden: ${err.message}</p>
                `;
            }
        }

        // Build tab buttons
        for (const entry of index) {
            const btn = document.createElement('button');
            btn.className = 'docs-tab';
            btn.textContent = entry.title || entry.file;
            btn.addEventListener('click', () => openDoc(entry, btn));
            docsTabList.appendChild(btn);
        }

        // Open first doc
        const first = index[0];
        const firstBtn = docsTabList.querySelector('button.docs-tab');
        if (first && firstBtn) openDoc(first, firstBtn);
    </script>
</body>
</html>
